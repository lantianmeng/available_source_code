// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trade.proto

#ifndef PROTOBUF_trade_2eproto__INCLUDED
#define PROTOBUF_trade_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_trade_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTradeOpenReqImpl();
void InitDefaultsTradeOpenReq();
void InitDefaultsTradeOpenRespImpl();
void InitDefaultsTradeOpenResp();
void InitDefaultsTradeOpenDataImpl();
void InitDefaultsTradeOpenData();
void InitDefaultsTradeCloseReqImpl();
void InitDefaultsTradeCloseReq();
void InitDefaultsTradeCloseRespImpl();
void InitDefaultsTradeCloseResp();
void InitDefaultsTradeCloseDataImpl();
void InitDefaultsTradeCloseData();
void InitDefaultsTradeUpdateReqImpl();
void InitDefaultsTradeUpdateReq();
void InitDefaultsTradeUpdateRespImpl();
void InitDefaultsTradeUpdateResp();
void InitDefaultsTradeUpdateDataImpl();
void InitDefaultsTradeUpdateData();
inline void InitDefaults() {
  InitDefaultsTradeOpenReq();
  InitDefaultsTradeOpenResp();
  InitDefaultsTradeOpenData();
  InitDefaultsTradeCloseReq();
  InitDefaultsTradeCloseResp();
  InitDefaultsTradeCloseData();
  InitDefaultsTradeUpdateReq();
  InitDefaultsTradeUpdateResp();
  InitDefaultsTradeUpdateData();
}
}  // namespace protobuf_trade_2eproto
namespace mt4api {
class TradeCloseData;
class TradeCloseDataDefaultTypeInternal;
extern TradeCloseDataDefaultTypeInternal _TradeCloseData_default_instance_;
class TradeCloseReq;
class TradeCloseReqDefaultTypeInternal;
extern TradeCloseReqDefaultTypeInternal _TradeCloseReq_default_instance_;
class TradeCloseResp;
class TradeCloseRespDefaultTypeInternal;
extern TradeCloseRespDefaultTypeInternal _TradeCloseResp_default_instance_;
class TradeOpenData;
class TradeOpenDataDefaultTypeInternal;
extern TradeOpenDataDefaultTypeInternal _TradeOpenData_default_instance_;
class TradeOpenReq;
class TradeOpenReqDefaultTypeInternal;
extern TradeOpenReqDefaultTypeInternal _TradeOpenReq_default_instance_;
class TradeOpenResp;
class TradeOpenRespDefaultTypeInternal;
extern TradeOpenRespDefaultTypeInternal _TradeOpenResp_default_instance_;
class TradeUpdateData;
class TradeUpdateDataDefaultTypeInternal;
extern TradeUpdateDataDefaultTypeInternal _TradeUpdateData_default_instance_;
class TradeUpdateReq;
class TradeUpdateReqDefaultTypeInternal;
extern TradeUpdateReqDefaultTypeInternal _TradeUpdateReq_default_instance_;
class TradeUpdateResp;
class TradeUpdateRespDefaultTypeInternal;
extern TradeUpdateRespDefaultTypeInternal _TradeUpdateResp_default_instance_;
}  // namespace mt4api
namespace mt4api {

// ===================================================================

class TradeOpenReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeOpenReq) */ {
 public:
  TradeOpenReq();
  virtual ~TradeOpenReq();

  TradeOpenReq(const TradeOpenReq& from);

  inline TradeOpenReq& operator=(const TradeOpenReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeOpenReq(TradeOpenReq&& from) noexcept
    : TradeOpenReq() {
    *this = ::std::move(from);
  }

  inline TradeOpenReq& operator=(TradeOpenReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeOpenReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeOpenReq* internal_default_instance() {
    return reinterpret_cast<const TradeOpenReq*>(
               &_TradeOpenReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(TradeOpenReq* other);
  void Swap(TradeOpenReq* other);
  friend void swap(TradeOpenReq& a, TradeOpenReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeOpenReq* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeOpenReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeOpenReq& from);
  void MergeFrom(const TradeOpenReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeOpenReq* other);
  protected:
  explicit TradeOpenReq(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Symbol = 1;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symbol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      ::std::string* symbol);

  // int32 MT4ID = 2;
  void clear_mt4id();
  static const int kMT4IDFieldNumber = 2;
  ::google::protobuf::int32 mt4id() const;
  void set_mt4id(::google::protobuf::int32 value);

  // int32 CMD = 3;
  void clear_cmd();
  static const int kCMDFieldNumber = 3;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // double OpenPrice = 5;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 5;
  double openprice() const;
  void set_openprice(double value);

  // double SL = 6;
  void clear_sl();
  static const int kSLFieldNumber = 6;
  double sl() const;
  void set_sl(double value);

  // double TP = 7;
  void clear_tp();
  static const int kTPFieldNumber = 7;
  double tp() const;
  void set_tp(double value);

  // int32 Volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeOpenReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 mt4id_;
  ::google::protobuf::int32 cmd_;
  double openprice_;
  double sl_;
  double tp_;
  ::google::protobuf::int32 volume_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeOpenReqImpl();
};
// -------------------------------------------------------------------

class TradeOpenResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeOpenResp) */ {
 public:
  TradeOpenResp();
  virtual ~TradeOpenResp();

  TradeOpenResp(const TradeOpenResp& from);

  inline TradeOpenResp& operator=(const TradeOpenResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeOpenResp(TradeOpenResp&& from) noexcept
    : TradeOpenResp() {
    *this = ::std::move(from);
  }

  inline TradeOpenResp& operator=(TradeOpenResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeOpenResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeOpenResp* internal_default_instance() {
    return reinterpret_cast<const TradeOpenResp*>(
               &_TradeOpenResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TradeOpenResp* other);
  void Swap(TradeOpenResp* other);
  friend void swap(TradeOpenResp& a, TradeOpenResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeOpenResp* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeOpenResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeOpenResp& from);
  void MergeFrom(const TradeOpenResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeOpenResp* other);
  protected:
  explicit TradeOpenResp(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mt4api.TradeOpenData Data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  void _slow_mutable_data();
  public:
  const ::mt4api::TradeOpenData& data() const;
  ::mt4api::TradeOpenData* release_data();
  ::mt4api::TradeOpenData* mutable_data();
  void set_allocated_data(::mt4api::TradeOpenData* data);
  void unsafe_arena_set_allocated_data(
      ::mt4api::TradeOpenData* data);
  ::mt4api::TradeOpenData* unsafe_arena_release_data();

  // int32 Code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeOpenResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mt4api::TradeOpenData* data_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeOpenRespImpl();
};
// -------------------------------------------------------------------

class TradeOpenData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeOpenData) */ {
 public:
  TradeOpenData();
  virtual ~TradeOpenData();

  TradeOpenData(const TradeOpenData& from);

  inline TradeOpenData& operator=(const TradeOpenData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeOpenData(TradeOpenData&& from) noexcept
    : TradeOpenData() {
    *this = ::std::move(from);
  }

  inline TradeOpenData& operator=(TradeOpenData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeOpenData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeOpenData* internal_default_instance() {
    return reinterpret_cast<const TradeOpenData*>(
               &_TradeOpenData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(TradeOpenData* other);
  void Swap(TradeOpenData* other);
  friend void swap(TradeOpenData& a, TradeOpenData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeOpenData* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeOpenData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeOpenData& from);
  void MergeFrom(const TradeOpenData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeOpenData* other);
  protected:
  explicit TradeOpenData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Symbol = 1;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symbol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      ::std::string* symbol);

  // int32 MT4ID = 2;
  void clear_mt4id();
  static const int kMT4IDFieldNumber = 2;
  ::google::protobuf::int32 mt4id() const;
  void set_mt4id(::google::protobuf::int32 value);

  // int32 CMD = 3;
  void clear_cmd();
  static const int kCMDFieldNumber = 3;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // int32 Volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // int32 Ticket = 5;
  void clear_ticket();
  static const int kTicketFieldNumber = 5;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // int64 OpenTime = 6;
  void clear_opentime();
  static const int kOpenTimeFieldNumber = 6;
  ::google::protobuf::int64 opentime() const;
  void set_opentime(::google::protobuf::int64 value);

  // double OpenPrice = 7;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 7;
  double openprice() const;
  void set_openprice(double value);

  // double SL = 8;
  void clear_sl();
  static const int kSLFieldNumber = 8;
  double sl() const;
  void set_sl(double value);

  // double TP = 9;
  void clear_tp();
  static const int kTPFieldNumber = 9;
  double tp() const;
  void set_tp(double value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeOpenData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 mt4id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int64 opentime_;
  double openprice_;
  double sl_;
  double tp_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeOpenDataImpl();
};
// -------------------------------------------------------------------

class TradeCloseReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeCloseReq) */ {
 public:
  TradeCloseReq();
  virtual ~TradeCloseReq();

  TradeCloseReq(const TradeCloseReq& from);

  inline TradeCloseReq& operator=(const TradeCloseReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeCloseReq(TradeCloseReq&& from) noexcept
    : TradeCloseReq() {
    *this = ::std::move(from);
  }

  inline TradeCloseReq& operator=(TradeCloseReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeCloseReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeCloseReq* internal_default_instance() {
    return reinterpret_cast<const TradeCloseReq*>(
               &_TradeCloseReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(TradeCloseReq* other);
  void Swap(TradeCloseReq* other);
  friend void swap(TradeCloseReq& a, TradeCloseReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeCloseReq* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeCloseReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeCloseReq& from);
  void MergeFrom(const TradeCloseReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeCloseReq* other);
  protected:
  explicit TradeCloseReq(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Symbol = 1;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symbol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      ::std::string* symbol);

  // int32 MT4ID = 2;
  void clear_mt4id();
  static const int kMT4IDFieldNumber = 2;
  ::google::protobuf::int32 mt4id() const;
  void set_mt4id(::google::protobuf::int32 value);

  // int32 CMD = 3;
  void clear_cmd();
  static const int kCMDFieldNumber = 3;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // int32 Volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // int32 Ticket = 5;
  void clear_ticket();
  static const int kTicketFieldNumber = 5;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeCloseReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 mt4id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 ticket_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeCloseReqImpl();
};
// -------------------------------------------------------------------

class TradeCloseResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeCloseResp) */ {
 public:
  TradeCloseResp();
  virtual ~TradeCloseResp();

  TradeCloseResp(const TradeCloseResp& from);

  inline TradeCloseResp& operator=(const TradeCloseResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeCloseResp(TradeCloseResp&& from) noexcept
    : TradeCloseResp() {
    *this = ::std::move(from);
  }

  inline TradeCloseResp& operator=(TradeCloseResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeCloseResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeCloseResp* internal_default_instance() {
    return reinterpret_cast<const TradeCloseResp*>(
               &_TradeCloseResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(TradeCloseResp* other);
  void Swap(TradeCloseResp* other);
  friend void swap(TradeCloseResp& a, TradeCloseResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeCloseResp* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeCloseResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeCloseResp& from);
  void MergeFrom(const TradeCloseResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeCloseResp* other);
  protected:
  explicit TradeCloseResp(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mt4api.TradeCloseData Data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  void _slow_mutable_data();
  public:
  const ::mt4api::TradeCloseData& data() const;
  ::mt4api::TradeCloseData* release_data();
  ::mt4api::TradeCloseData* mutable_data();
  void set_allocated_data(::mt4api::TradeCloseData* data);
  void unsafe_arena_set_allocated_data(
      ::mt4api::TradeCloseData* data);
  ::mt4api::TradeCloseData* unsafe_arena_release_data();

  // int32 Code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeCloseResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mt4api::TradeCloseData* data_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeCloseRespImpl();
};
// -------------------------------------------------------------------

class TradeCloseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeCloseData) */ {
 public:
  TradeCloseData();
  virtual ~TradeCloseData();

  TradeCloseData(const TradeCloseData& from);

  inline TradeCloseData& operator=(const TradeCloseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeCloseData(TradeCloseData&& from) noexcept
    : TradeCloseData() {
    *this = ::std::move(from);
  }

  inline TradeCloseData& operator=(TradeCloseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeCloseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeCloseData* internal_default_instance() {
    return reinterpret_cast<const TradeCloseData*>(
               &_TradeCloseData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(TradeCloseData* other);
  void Swap(TradeCloseData* other);
  friend void swap(TradeCloseData& a, TradeCloseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeCloseData* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeCloseData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeCloseData& from);
  void MergeFrom(const TradeCloseData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeCloseData* other);
  protected:
  explicit TradeCloseData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Symbol = 1;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symbol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      ::std::string* symbol);

  // int32 MT4ID = 2;
  void clear_mt4id();
  static const int kMT4IDFieldNumber = 2;
  ::google::protobuf::int32 mt4id() const;
  void set_mt4id(::google::protobuf::int32 value);

  // int32 CMD = 3;
  void clear_cmd();
  static const int kCMDFieldNumber = 3;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // int32 Volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // int32 Ticket = 5;
  void clear_ticket();
  static const int kTicketFieldNumber = 5;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // int64 CloseTime = 6;
  void clear_closetime();
  static const int kCloseTimeFieldNumber = 6;
  ::google::protobuf::int64 closetime() const;
  void set_closetime(::google::protobuf::int64 value);

  // int64 OpenTime = 7;
  void clear_opentime();
  static const int kOpenTimeFieldNumber = 7;
  ::google::protobuf::int64 opentime() const;
  void set_opentime(::google::protobuf::int64 value);

  // double ClosePrice = 8;
  void clear_closeprice();
  static const int kClosePriceFieldNumber = 8;
  double closeprice() const;
  void set_closeprice(double value);

  // double OpenPrice = 9;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 9;
  double openprice() const;
  void set_openprice(double value);

  // double SL = 10;
  void clear_sl();
  static const int kSLFieldNumber = 10;
  double sl() const;
  void set_sl(double value);

  // double TP = 11;
  void clear_tp();
  static const int kTPFieldNumber = 11;
  double tp() const;
  void set_tp(double value);

  // double Profit = 12;
  void clear_profit();
  static const int kProfitFieldNumber = 12;
  double profit() const;
  void set_profit(double value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeCloseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 mt4id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int64 closetime_;
  ::google::protobuf::int64 opentime_;
  double closeprice_;
  double openprice_;
  double sl_;
  double tp_;
  double profit_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeCloseDataImpl();
};
// -------------------------------------------------------------------

class TradeUpdateReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeUpdateReq) */ {
 public:
  TradeUpdateReq();
  virtual ~TradeUpdateReq();

  TradeUpdateReq(const TradeUpdateReq& from);

  inline TradeUpdateReq& operator=(const TradeUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeUpdateReq(TradeUpdateReq&& from) noexcept
    : TradeUpdateReq() {
    *this = ::std::move(from);
  }

  inline TradeUpdateReq& operator=(TradeUpdateReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeUpdateReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeUpdateReq* internal_default_instance() {
    return reinterpret_cast<const TradeUpdateReq*>(
               &_TradeUpdateReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(TradeUpdateReq* other);
  void Swap(TradeUpdateReq* other);
  friend void swap(TradeUpdateReq& a, TradeUpdateReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeUpdateReq* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeUpdateReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeUpdateReq& from);
  void MergeFrom(const TradeUpdateReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeUpdateReq* other);
  protected:
  explicit TradeUpdateReq(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Symbol = 1;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symbol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbol(
      ::std::string* symbol);

  // int32 MT4ID = 2;
  void clear_mt4id();
  static const int kMT4IDFieldNumber = 2;
  ::google::protobuf::int32 mt4id() const;
  void set_mt4id(::google::protobuf::int32 value);

  // int32 CMD = 3;
  void clear_cmd();
  static const int kCMDFieldNumber = 3;
  ::google::protobuf::int32 cmd() const;
  void set_cmd(::google::protobuf::int32 value);

  // int32 Volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // int32 Ticket = 5;
  void clear_ticket();
  static const int kTicketFieldNumber = 5;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // double OpenPrice = 6;
  void clear_openprice();
  static const int kOpenPriceFieldNumber = 6;
  double openprice() const;
  void set_openprice(double value);

  // double SL = 7;
  void clear_sl();
  static const int kSLFieldNumber = 7;
  double sl() const;
  void set_sl(double value);

  // double TP = 8;
  void clear_tp();
  static const int kTPFieldNumber = 8;
  double tp() const;
  void set_tp(double value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeUpdateReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int32 mt4id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 ticket_;
  double openprice_;
  double sl_;
  double tp_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeUpdateReqImpl();
};
// -------------------------------------------------------------------

class TradeUpdateResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeUpdateResp) */ {
 public:
  TradeUpdateResp();
  virtual ~TradeUpdateResp();

  TradeUpdateResp(const TradeUpdateResp& from);

  inline TradeUpdateResp& operator=(const TradeUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeUpdateResp(TradeUpdateResp&& from) noexcept
    : TradeUpdateResp() {
    *this = ::std::move(from);
  }

  inline TradeUpdateResp& operator=(TradeUpdateResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeUpdateResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeUpdateResp* internal_default_instance() {
    return reinterpret_cast<const TradeUpdateResp*>(
               &_TradeUpdateResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(TradeUpdateResp* other);
  void Swap(TradeUpdateResp* other);
  friend void swap(TradeUpdateResp& a, TradeUpdateResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeUpdateResp* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeUpdateResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeUpdateResp& from);
  void MergeFrom(const TradeUpdateResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeUpdateResp* other);
  protected:
  explicit TradeUpdateResp(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mt4api.TradeUpdateData Data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  void _slow_mutable_data();
  public:
  const ::mt4api::TradeUpdateData& data() const;
  ::mt4api::TradeUpdateData* release_data();
  ::mt4api::TradeUpdateData* mutable_data();
  void set_allocated_data(::mt4api::TradeUpdateData* data);
  void unsafe_arena_set_allocated_data(
      ::mt4api::TradeUpdateData* data);
  ::mt4api::TradeUpdateData* unsafe_arena_release_data();

  // int32 Code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeUpdateResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mt4api::TradeUpdateData* data_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeUpdateRespImpl();
};
// -------------------------------------------------------------------

class TradeUpdateData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mt4api.TradeUpdateData) */ {
 public:
  TradeUpdateData();
  virtual ~TradeUpdateData();

  TradeUpdateData(const TradeUpdateData& from);

  inline TradeUpdateData& operator=(const TradeUpdateData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeUpdateData(TradeUpdateData&& from) noexcept
    : TradeUpdateData() {
    *this = ::std::move(from);
  }

  inline TradeUpdateData& operator=(TradeUpdateData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeUpdateData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeUpdateData* internal_default_instance() {
    return reinterpret_cast<const TradeUpdateData*>(
               &_TradeUpdateData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(TradeUpdateData* other);
  void Swap(TradeUpdateData* other);
  friend void swap(TradeUpdateData& a, TradeUpdateData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeUpdateData* New() const PROTOBUF_FINAL { return New(NULL); }

  TradeUpdateData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TradeUpdateData& from);
  void MergeFrom(const TradeUpdateData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TradeUpdateData* other);
  protected:
  explicit TradeUpdateData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double SL = 1;
  void clear_sl();
  static const int kSLFieldNumber = 1;
  double sl() const;
  void set_sl(double value);

  // double TP = 2;
  void clear_tp();
  static const int kTPFieldNumber = 2;
  double tp() const;
  void set_tp(double value);

  // @@protoc_insertion_point(class_scope:mt4api.TradeUpdateData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double sl_;
  double tp_;
  mutable int _cached_size_;
  friend struct ::protobuf_trade_2eproto::TableStruct;
  friend void ::protobuf_trade_2eproto::InitDefaultsTradeUpdateDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TradeOpenReq

// string Symbol = 1;
inline void TradeOpenReq::clear_symbol() {
  symbol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TradeOpenReq::symbol() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.Symbol)
  return symbol_.Get();
}
inline void TradeOpenReq::set_symbol(const ::std::string& value) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.Symbol)
}
#if LANG_CXX11
inline void TradeOpenReq::set_symbol(::std::string&& value) {
  
  symbol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mt4api.TradeOpenReq.Symbol)
}
#endif
inline void TradeOpenReq::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mt4api.TradeOpenReq.Symbol)
}
inline void TradeOpenReq::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mt4api.TradeOpenReq.Symbol)
}
inline ::std::string* TradeOpenReq::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:mt4api.TradeOpenReq.Symbol)
  return symbol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TradeOpenReq::release_symbol() {
  // @@protoc_insertion_point(field_release:mt4api.TradeOpenReq.Symbol)
  
  return symbol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TradeOpenReq::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeOpenReq.Symbol)
}
inline ::std::string* TradeOpenReq::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeOpenReq.Symbol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return symbol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TradeOpenReq::unsafe_arena_set_allocated_symbol(
    ::std::string* symbol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mt4api.TradeOpenReq.Symbol)
}

// int32 MT4ID = 2;
inline void TradeOpenReq::clear_mt4id() {
  mt4id_ = 0;
}
inline ::google::protobuf::int32 TradeOpenReq::mt4id() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.MT4ID)
  return mt4id_;
}
inline void TradeOpenReq::set_mt4id(::google::protobuf::int32 value) {
  
  mt4id_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.MT4ID)
}

// int32 CMD = 3;
inline void TradeOpenReq::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 TradeOpenReq::cmd() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.CMD)
  return cmd_;
}
inline void TradeOpenReq::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.CMD)
}

// int32 Volume = 4;
inline void TradeOpenReq::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 TradeOpenReq::volume() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.Volume)
  return volume_;
}
inline void TradeOpenReq::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.Volume)
}

// double OpenPrice = 5;
inline void TradeOpenReq::clear_openprice() {
  openprice_ = 0;
}
inline double TradeOpenReq::openprice() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.OpenPrice)
  return openprice_;
}
inline void TradeOpenReq::set_openprice(double value) {
  
  openprice_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.OpenPrice)
}

// double SL = 6;
inline void TradeOpenReq::clear_sl() {
  sl_ = 0;
}
inline double TradeOpenReq::sl() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.SL)
  return sl_;
}
inline void TradeOpenReq::set_sl(double value) {
  
  sl_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.SL)
}

// double TP = 7;
inline void TradeOpenReq::clear_tp() {
  tp_ = 0;
}
inline double TradeOpenReq::tp() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenReq.TP)
  return tp_;
}
inline void TradeOpenReq::set_tp(double value) {
  
  tp_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenReq.TP)
}

// -------------------------------------------------------------------

// TradeOpenResp

// int32 Code = 1;
inline void TradeOpenResp::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 TradeOpenResp::code() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenResp.Code)
  return code_;
}
inline void TradeOpenResp::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenResp.Code)
}

// .mt4api.TradeOpenData Data = 2;
inline bool TradeOpenResp::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void TradeOpenResp::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::mt4api::TradeOpenData& TradeOpenResp::data() const {
  const ::mt4api::TradeOpenData* p = data_;
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenResp.Data)
  return p != NULL ? *p : *reinterpret_cast<const ::mt4api::TradeOpenData*>(
      &::mt4api::_TradeOpenData_default_instance_);
}
inline ::mt4api::TradeOpenData* TradeOpenResp::release_data() {
  // @@protoc_insertion_point(field_release:mt4api.TradeOpenResp.Data)
  
  ::mt4api::TradeOpenData* temp = data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeOpenData* TradeOpenResp::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeOpenResp.Data)
  
  ::mt4api::TradeOpenData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeOpenData* TradeOpenResp::mutable_data() {
  
  if (data_ == NULL) {
    _slow_mutable_data();
  }
  // @@protoc_insertion_point(field_mutable:mt4api.TradeOpenResp.Data)
  return data_;
}
inline void TradeOpenResp::set_allocated_data(::mt4api::TradeOpenData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeOpenResp.Data)
}

// -------------------------------------------------------------------

// TradeOpenData

// string Symbol = 1;
inline void TradeOpenData::clear_symbol() {
  symbol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TradeOpenData::symbol() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.Symbol)
  return symbol_.Get();
}
inline void TradeOpenData::set_symbol(const ::std::string& value) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.Symbol)
}
#if LANG_CXX11
inline void TradeOpenData::set_symbol(::std::string&& value) {
  
  symbol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mt4api.TradeOpenData.Symbol)
}
#endif
inline void TradeOpenData::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mt4api.TradeOpenData.Symbol)
}
inline void TradeOpenData::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mt4api.TradeOpenData.Symbol)
}
inline ::std::string* TradeOpenData::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:mt4api.TradeOpenData.Symbol)
  return symbol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TradeOpenData::release_symbol() {
  // @@protoc_insertion_point(field_release:mt4api.TradeOpenData.Symbol)
  
  return symbol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TradeOpenData::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeOpenData.Symbol)
}
inline ::std::string* TradeOpenData::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeOpenData.Symbol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return symbol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TradeOpenData::unsafe_arena_set_allocated_symbol(
    ::std::string* symbol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mt4api.TradeOpenData.Symbol)
}

// int32 MT4ID = 2;
inline void TradeOpenData::clear_mt4id() {
  mt4id_ = 0;
}
inline ::google::protobuf::int32 TradeOpenData::mt4id() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.MT4ID)
  return mt4id_;
}
inline void TradeOpenData::set_mt4id(::google::protobuf::int32 value) {
  
  mt4id_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.MT4ID)
}

// int32 CMD = 3;
inline void TradeOpenData::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 TradeOpenData::cmd() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.CMD)
  return cmd_;
}
inline void TradeOpenData::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.CMD)
}

// int32 Volume = 4;
inline void TradeOpenData::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 TradeOpenData::volume() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.Volume)
  return volume_;
}
inline void TradeOpenData::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.Volume)
}

// int32 Ticket = 5;
inline void TradeOpenData::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 TradeOpenData::ticket() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.Ticket)
  return ticket_;
}
inline void TradeOpenData::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.Ticket)
}

// int64 OpenTime = 6;
inline void TradeOpenData::clear_opentime() {
  opentime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeOpenData::opentime() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.OpenTime)
  return opentime_;
}
inline void TradeOpenData::set_opentime(::google::protobuf::int64 value) {
  
  opentime_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.OpenTime)
}

// double OpenPrice = 7;
inline void TradeOpenData::clear_openprice() {
  openprice_ = 0;
}
inline double TradeOpenData::openprice() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.OpenPrice)
  return openprice_;
}
inline void TradeOpenData::set_openprice(double value) {
  
  openprice_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.OpenPrice)
}

// double SL = 8;
inline void TradeOpenData::clear_sl() {
  sl_ = 0;
}
inline double TradeOpenData::sl() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.SL)
  return sl_;
}
inline void TradeOpenData::set_sl(double value) {
  
  sl_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.SL)
}

// double TP = 9;
inline void TradeOpenData::clear_tp() {
  tp_ = 0;
}
inline double TradeOpenData::tp() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeOpenData.TP)
  return tp_;
}
inline void TradeOpenData::set_tp(double value) {
  
  tp_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeOpenData.TP)
}

// -------------------------------------------------------------------

// TradeCloseReq

// string Symbol = 1;
inline void TradeCloseReq::clear_symbol() {
  symbol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TradeCloseReq::symbol() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseReq.Symbol)
  return symbol_.Get();
}
inline void TradeCloseReq::set_symbol(const ::std::string& value) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseReq.Symbol)
}
#if LANG_CXX11
inline void TradeCloseReq::set_symbol(::std::string&& value) {
  
  symbol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mt4api.TradeCloseReq.Symbol)
}
#endif
inline void TradeCloseReq::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mt4api.TradeCloseReq.Symbol)
}
inline void TradeCloseReq::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mt4api.TradeCloseReq.Symbol)
}
inline ::std::string* TradeCloseReq::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:mt4api.TradeCloseReq.Symbol)
  return symbol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TradeCloseReq::release_symbol() {
  // @@protoc_insertion_point(field_release:mt4api.TradeCloseReq.Symbol)
  
  return symbol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TradeCloseReq::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeCloseReq.Symbol)
}
inline ::std::string* TradeCloseReq::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeCloseReq.Symbol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return symbol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TradeCloseReq::unsafe_arena_set_allocated_symbol(
    ::std::string* symbol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mt4api.TradeCloseReq.Symbol)
}

// int32 MT4ID = 2;
inline void TradeCloseReq::clear_mt4id() {
  mt4id_ = 0;
}
inline ::google::protobuf::int32 TradeCloseReq::mt4id() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseReq.MT4ID)
  return mt4id_;
}
inline void TradeCloseReq::set_mt4id(::google::protobuf::int32 value) {
  
  mt4id_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseReq.MT4ID)
}

// int32 CMD = 3;
inline void TradeCloseReq::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 TradeCloseReq::cmd() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseReq.CMD)
  return cmd_;
}
inline void TradeCloseReq::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseReq.CMD)
}

// int32 Volume = 4;
inline void TradeCloseReq::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 TradeCloseReq::volume() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseReq.Volume)
  return volume_;
}
inline void TradeCloseReq::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseReq.Volume)
}

// int32 Ticket = 5;
inline void TradeCloseReq::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 TradeCloseReq::ticket() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseReq.Ticket)
  return ticket_;
}
inline void TradeCloseReq::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseReq.Ticket)
}

// -------------------------------------------------------------------

// TradeCloseResp

// int32 Code = 1;
inline void TradeCloseResp::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 TradeCloseResp::code() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseResp.Code)
  return code_;
}
inline void TradeCloseResp::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseResp.Code)
}

// .mt4api.TradeCloseData Data = 2;
inline bool TradeCloseResp::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void TradeCloseResp::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::mt4api::TradeCloseData& TradeCloseResp::data() const {
  const ::mt4api::TradeCloseData* p = data_;
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseResp.Data)
  return p != NULL ? *p : *reinterpret_cast<const ::mt4api::TradeCloseData*>(
      &::mt4api::_TradeCloseData_default_instance_);
}
inline ::mt4api::TradeCloseData* TradeCloseResp::release_data() {
  // @@protoc_insertion_point(field_release:mt4api.TradeCloseResp.Data)
  
  ::mt4api::TradeCloseData* temp = data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeCloseData* TradeCloseResp::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeCloseResp.Data)
  
  ::mt4api::TradeCloseData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeCloseData* TradeCloseResp::mutable_data() {
  
  if (data_ == NULL) {
    _slow_mutable_data();
  }
  // @@protoc_insertion_point(field_mutable:mt4api.TradeCloseResp.Data)
  return data_;
}
inline void TradeCloseResp::set_allocated_data(::mt4api::TradeCloseData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeCloseResp.Data)
}

// -------------------------------------------------------------------

// TradeCloseData

// string Symbol = 1;
inline void TradeCloseData::clear_symbol() {
  symbol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TradeCloseData::symbol() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.Symbol)
  return symbol_.Get();
}
inline void TradeCloseData::set_symbol(const ::std::string& value) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.Symbol)
}
#if LANG_CXX11
inline void TradeCloseData::set_symbol(::std::string&& value) {
  
  symbol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mt4api.TradeCloseData.Symbol)
}
#endif
inline void TradeCloseData::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mt4api.TradeCloseData.Symbol)
}
inline void TradeCloseData::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mt4api.TradeCloseData.Symbol)
}
inline ::std::string* TradeCloseData::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:mt4api.TradeCloseData.Symbol)
  return symbol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TradeCloseData::release_symbol() {
  // @@protoc_insertion_point(field_release:mt4api.TradeCloseData.Symbol)
  
  return symbol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TradeCloseData::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeCloseData.Symbol)
}
inline ::std::string* TradeCloseData::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeCloseData.Symbol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return symbol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TradeCloseData::unsafe_arena_set_allocated_symbol(
    ::std::string* symbol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mt4api.TradeCloseData.Symbol)
}

// int32 MT4ID = 2;
inline void TradeCloseData::clear_mt4id() {
  mt4id_ = 0;
}
inline ::google::protobuf::int32 TradeCloseData::mt4id() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.MT4ID)
  return mt4id_;
}
inline void TradeCloseData::set_mt4id(::google::protobuf::int32 value) {
  
  mt4id_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.MT4ID)
}

// int32 CMD = 3;
inline void TradeCloseData::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 TradeCloseData::cmd() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.CMD)
  return cmd_;
}
inline void TradeCloseData::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.CMD)
}

// int32 Volume = 4;
inline void TradeCloseData::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 TradeCloseData::volume() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.Volume)
  return volume_;
}
inline void TradeCloseData::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.Volume)
}

// int32 Ticket = 5;
inline void TradeCloseData::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 TradeCloseData::ticket() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.Ticket)
  return ticket_;
}
inline void TradeCloseData::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.Ticket)
}

// int64 CloseTime = 6;
inline void TradeCloseData::clear_closetime() {
  closetime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeCloseData::closetime() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.CloseTime)
  return closetime_;
}
inline void TradeCloseData::set_closetime(::google::protobuf::int64 value) {
  
  closetime_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.CloseTime)
}

// int64 OpenTime = 7;
inline void TradeCloseData::clear_opentime() {
  opentime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeCloseData::opentime() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.OpenTime)
  return opentime_;
}
inline void TradeCloseData::set_opentime(::google::protobuf::int64 value) {
  
  opentime_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.OpenTime)
}

// double ClosePrice = 8;
inline void TradeCloseData::clear_closeprice() {
  closeprice_ = 0;
}
inline double TradeCloseData::closeprice() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.ClosePrice)
  return closeprice_;
}
inline void TradeCloseData::set_closeprice(double value) {
  
  closeprice_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.ClosePrice)
}

// double OpenPrice = 9;
inline void TradeCloseData::clear_openprice() {
  openprice_ = 0;
}
inline double TradeCloseData::openprice() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.OpenPrice)
  return openprice_;
}
inline void TradeCloseData::set_openprice(double value) {
  
  openprice_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.OpenPrice)
}

// double SL = 10;
inline void TradeCloseData::clear_sl() {
  sl_ = 0;
}
inline double TradeCloseData::sl() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.SL)
  return sl_;
}
inline void TradeCloseData::set_sl(double value) {
  
  sl_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.SL)
}

// double TP = 11;
inline void TradeCloseData::clear_tp() {
  tp_ = 0;
}
inline double TradeCloseData::tp() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.TP)
  return tp_;
}
inline void TradeCloseData::set_tp(double value) {
  
  tp_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.TP)
}

// double Profit = 12;
inline void TradeCloseData::clear_profit() {
  profit_ = 0;
}
inline double TradeCloseData::profit() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeCloseData.Profit)
  return profit_;
}
inline void TradeCloseData::set_profit(double value) {
  
  profit_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeCloseData.Profit)
}

// -------------------------------------------------------------------

// TradeUpdateReq

// string Symbol = 1;
inline void TradeUpdateReq::clear_symbol() {
  symbol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TradeUpdateReq::symbol() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.Symbol)
  return symbol_.Get();
}
inline void TradeUpdateReq::set_symbol(const ::std::string& value) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.Symbol)
}
#if LANG_CXX11
inline void TradeUpdateReq::set_symbol(::std::string&& value) {
  
  symbol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mt4api.TradeUpdateReq.Symbol)
}
#endif
inline void TradeUpdateReq::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mt4api.TradeUpdateReq.Symbol)
}
inline void TradeUpdateReq::set_symbol(const char* value,
    size_t size) {
  
  symbol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mt4api.TradeUpdateReq.Symbol)
}
inline ::std::string* TradeUpdateReq::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:mt4api.TradeUpdateReq.Symbol)
  return symbol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TradeUpdateReq::release_symbol() {
  // @@protoc_insertion_point(field_release:mt4api.TradeUpdateReq.Symbol)
  
  return symbol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TradeUpdateReq::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeUpdateReq.Symbol)
}
inline ::std::string* TradeUpdateReq::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeUpdateReq.Symbol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return symbol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TradeUpdateReq::unsafe_arena_set_allocated_symbol(
    ::std::string* symbol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symbol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mt4api.TradeUpdateReq.Symbol)
}

// int32 MT4ID = 2;
inline void TradeUpdateReq::clear_mt4id() {
  mt4id_ = 0;
}
inline ::google::protobuf::int32 TradeUpdateReq::mt4id() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.MT4ID)
  return mt4id_;
}
inline void TradeUpdateReq::set_mt4id(::google::protobuf::int32 value) {
  
  mt4id_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.MT4ID)
}

// int32 CMD = 3;
inline void TradeUpdateReq::clear_cmd() {
  cmd_ = 0;
}
inline ::google::protobuf::int32 TradeUpdateReq::cmd() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.CMD)
  return cmd_;
}
inline void TradeUpdateReq::set_cmd(::google::protobuf::int32 value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.CMD)
}

// int32 Volume = 4;
inline void TradeUpdateReq::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 TradeUpdateReq::volume() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.Volume)
  return volume_;
}
inline void TradeUpdateReq::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.Volume)
}

// int32 Ticket = 5;
inline void TradeUpdateReq::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 TradeUpdateReq::ticket() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.Ticket)
  return ticket_;
}
inline void TradeUpdateReq::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.Ticket)
}

// double OpenPrice = 6;
inline void TradeUpdateReq::clear_openprice() {
  openprice_ = 0;
}
inline double TradeUpdateReq::openprice() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.OpenPrice)
  return openprice_;
}
inline void TradeUpdateReq::set_openprice(double value) {
  
  openprice_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.OpenPrice)
}

// double SL = 7;
inline void TradeUpdateReq::clear_sl() {
  sl_ = 0;
}
inline double TradeUpdateReq::sl() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.SL)
  return sl_;
}
inline void TradeUpdateReq::set_sl(double value) {
  
  sl_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.SL)
}

// double TP = 8;
inline void TradeUpdateReq::clear_tp() {
  tp_ = 0;
}
inline double TradeUpdateReq::tp() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateReq.TP)
  return tp_;
}
inline void TradeUpdateReq::set_tp(double value) {
  
  tp_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateReq.TP)
}

// -------------------------------------------------------------------

// TradeUpdateResp

// int32 Code = 1;
inline void TradeUpdateResp::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 TradeUpdateResp::code() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateResp.Code)
  return code_;
}
inline void TradeUpdateResp::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateResp.Code)
}

// .mt4api.TradeUpdateData Data = 2;
inline bool TradeUpdateResp::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void TradeUpdateResp::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::mt4api::TradeUpdateData& TradeUpdateResp::data() const {
  const ::mt4api::TradeUpdateData* p = data_;
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateResp.Data)
  return p != NULL ? *p : *reinterpret_cast<const ::mt4api::TradeUpdateData*>(
      &::mt4api::_TradeUpdateData_default_instance_);
}
inline ::mt4api::TradeUpdateData* TradeUpdateResp::release_data() {
  // @@protoc_insertion_point(field_release:mt4api.TradeUpdateResp.Data)
  
  ::mt4api::TradeUpdateData* temp = data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeUpdateData* TradeUpdateResp::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mt4api.TradeUpdateResp.Data)
  
  ::mt4api::TradeUpdateData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::mt4api::TradeUpdateData* TradeUpdateResp::mutable_data() {
  
  if (data_ == NULL) {
    _slow_mutable_data();
  }
  // @@protoc_insertion_point(field_mutable:mt4api.TradeUpdateResp.Data)
  return data_;
}
inline void TradeUpdateResp::set_allocated_data(::mt4api::TradeUpdateData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mt4api.TradeUpdateResp.Data)
}

// -------------------------------------------------------------------

// TradeUpdateData

// double SL = 1;
inline void TradeUpdateData::clear_sl() {
  sl_ = 0;
}
inline double TradeUpdateData::sl() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateData.SL)
  return sl_;
}
inline void TradeUpdateData::set_sl(double value) {
  
  sl_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateData.SL)
}

// double TP = 2;
inline void TradeUpdateData::clear_tp() {
  tp_ = 0;
}
inline double TradeUpdateData::tp() const {
  // @@protoc_insertion_point(field_get:mt4api.TradeUpdateData.TP)
  return tp_;
}
inline void TradeUpdateData::set_tp(double value) {
  
  tp_ = value;
  // @@protoc_insertion_point(field_set:mt4api.TradeUpdateData.TP)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mt4api

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trade_2eproto__INCLUDED
